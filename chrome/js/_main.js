
function kGit()
{
  this.loadExtension = function(event)
  {
	event.currentTarget.removeEventListener('load', kgit.loadExtension, false);
	kgit.initExtension();
  }
  this.unloadExtension = function(event)
  {
	event.currentTarget.removeEventListener('unload', kgit.unloadExtension, false);
	kgit.uninitExtension();
  }
  this.uninitExtension = function()
  {
	this.kGitIconsOverlay.uninit();
  }
  this.initExtension = function()
  {
	this.debug = true;

	//global singleton object "s"
	  Components.utils.import('resource://up.tito.kgit/_init.js', this);
	  this.s.extensionID = 'tito@kgit';
	  this.s.extensionName = 'Komodin Git';
	  this.s.extensionChromeName = 'kgit';
	  this.s.include('observer','hash','application','preference','file','string','thread','prompt','extension','urls','array','date','document','tab','window','notification','listener','places','shell','timer','sharedMemory','measureTime');
	  this.windowID = this.s.getWindowID();
	//end global singleton object
	
	/*
	  In order to get the python component properly loaded the extension should be located into the "application" folder, and not into the profile folder.
	*/
	this.s.extensionsMoveToApplicationDirectory();
	
	//if not yet set, set the paths to git(bash)
	if(this.s.isWindows())
	{
	  this.gitPath = this.s.pref('gitPath');
	 
	  while(!this.s.fileExists(this.gitPath+this.s.__DS+'bin'+this.s.__DS+'bash.exe'))
	  {
		window.focus();
		window.getAttention();
		this.gitPath = this.s.folderAskUser("Please select the Git directory. ( Usually 'C:/Program Files/Git/'");
		
		if(!this.gitPath)
		  break;
		else if(this.s.fileExists(this.gitPath+this.s.__DS+'bin'+this.s.__DS+'bash.exe'))
		{
		  this.s.pref('gitPath', this.gitPath);
		  this.s.restart();
		  break;
		}
	  }
	  if(!this.s.fileExists(this.gitPath+this.s.__DS+'bin'+this.s.__DS+'bash.exe'))
		this.gitPathSet = false;
	  else
		this.gitPathSet = true;
	  if(!this.gitPathSet)
	  {
		this.disable();
		return;
	  }
	}

	//window globals
	this.itemsLoading = 0;
	this.runSvc = Components
					.classes["@activestate.com/koRunService;1"]
					.createInstance(Components.interfaces.koIRunService);

	this.s.addObserver('quit-application-requested', function(){ kgit.s.folderDeleteTemporal();});

	this.s.addListener(
					   {'id':this.windowID,'window':window},
					   'onLocationChange',
					   function(aTab){ kgit.onLocationChange(aTab);}
					  );
	
	this.filesStatus = [];
	
	this.kGitIconsOverlay = new kGitIconsOverlay();
	this.kGitIconsOverlay.s = this.s;
	this.kGitIconsOverlay.gitPath = this.gitPath;
	this.kGitIconsOverlay.init();
	return;
  }
 
  //this disable the git buttons when viewing documents generated by this extesion, such diff files
  this.onLocationChange = function(aTab)
  {
	var aLocation = this.s.documentGetLocation(this.s.documentGetFromTab(aTab));
	var aMenus = [
				  'kgit-toolbarbutton',
				  'kgit-tab-context-menu',
				  'kgit-menu-bar-file',
				  'kgit-document-context-menu'
				  ]
	if(aLocation.indexOf('tito@kgit') != -1)
	{
	  for(var id in aMenus)
		this.element(aMenus[id]).setAttribute('disabled', true);
	}
	else
	{
	  for(var id in aMenus)
		this.element(aMenus[id]).removeAttribute('disabled');
	}
  }
 
  //runs a shell script and display or return the output
  this.run = function(aScriptPath, aOutputPath, aMsg, openInNewTab, displayIntoNotificationBox, aReturnOutput)
  {
	this.loadingSet();
	
	//if *nix
	if(this.s.__DS == '/')
	{
	  var process =  this.runSvc.RunAndNotify(
										'sh '+this.s.filePathEscape(aScriptPath)+'',
										'/bin',
										'',
										'');
	}
	else
	{
	  //if windows
	  var process =  this.runSvc.RunAndNotify(
										'bash.exe --login "'+this.s.filePathEscape(aScriptPath)+'"',
										this.gitPath+'\\bin\\',
										'',
										'');
	}
	var retval = process.wait(-1);

	if(displayIntoNotificationBox)
	{
	  if(this.s.fileRead(aOutputPath) != '')
		this.s.notifyTab(document, this.s.fileRead(aOutputPath));
	  else
		ko.statusBar.AddMessage('kGit: Command complete '+aMsg, "kgit", 7 * 1000, true);
	}
	else if(openInNewTab)
	{
	  if(this.s.fileRead(aOutputPath) != '')
		this.s.openURL(window, aOutputPath, true);
	  else
		ko.statusBar.AddMessage('kGit: Command complete '+aMsg, "kgit", 7 * 1000, true);
	}
	else if(!aReturnOutput)
	{
	  if(this.s.fileRead(aOutputPath) != '')
		this.s.commandOutput(window, this.s.fileRead(aOutputPath));
	  else
		ko.statusBar.AddMessage('kGit: Command complete '+aMsg, "kgit", 7 * 1000, true);
	}
	var stderr = process.getStderr();
	if(stderr && stderr != '')
	{
	  if(stderr.indexOf('Not a git repository (or any of the parent directories): .git') != -1)
		ko.statusBar.AddMessage('kGit: File/Folder not in a git repository', "kgit", 7 * 1000, true);
	  else
		this.s.alert('Error:\n'+stderr);
	}

	if(aReturnOutput)
	  var stdout = process.getStdout();
	  
	this.loadingRemove();
	
	process = null;
	retval = null;
	stderr = null;
	aScriptPath = null;
	aOutputPath = null;
	openInNewTab = null;
	displayIntoNotificationBox = null;
	
	this.kGitIconsOverlay.requestUpdate();
	
	if(aReturnOutput)
	  return stdout;
  }


  this.executeObserver = function(aScriptPath, aOutputPath, inNewTab)
  {
	if(!aOutputPath){}
	else
	{
	  if(!inNewTab)
		kgit.s.notifyTab(document, kgit.s.fileRead(aOutputPath));
	  else
	  {
		if(kgit.s.fileRead(aOutputPath) != '')
		  kgit.s.openURL(window, aOutputPath, true);
	  }
	}
	kgit.kGitIconsOverlay.requestUpdate();
	kgit.loadingRemove();
  }
  
  //returns selected URIs
	//from focused document (if the event comes from the toolbarbutton ) or
	//from focused files and/or folders of the places sidebar
	//places root folder if no selection on the places sidebar
	//places root folder if right click on "placesRootButton"
	//assumes document unless noted different with target attribute of parent parent

  this.getCurrentPath = function()
  {
	//if garden is not installed or "places" extension is focused
	if(typeof(gardenAPI) == 'undefined' || (ko.places && ko.places.viewMgr &&
				   (
					ko.places.viewMgr.focused ||
					(document.popupNode && document.popupNode.id && document.popupNode.id == 'placesRootButton')
					)) )
	  var selected = this.s.filePathFromFileURI(this.s.placesLocalCurrentPath(window));
	else
	  var selected = gardenAPI.getFocusedPathLocal();

	return selected;
  }
  this._getSelectedPaths = function(aboutFocusedTab)
  {
	//if garden is not installed or "places" extension is focused
	if(typeof(gardenAPI) == 'undefined' || (ko.places && ko.places.viewMgr &&
				   (
					ko.places.viewMgr.focused ||
					(document.popupNode && document.popupNode.id && document.popupNode.id == 'placesRootButton')
				   )
				   ) )
	  var selected = this.s.placesLocalGetSelectedPaths(window, aboutFocusedTab);
	else
	  var selected = gardenAPI.getSelectedPaths(aboutFocusedTab);

	return selected;
  }
  this.getSelectedPaths = function(event)
  {
	if(
	   event &&
	   event.originalTarget.parentNode &&
	   event.originalTarget.parentNode.parentNode &&
	   (
		( //click on menu
		  event.originalTarget.parentNode.parentNode.hasAttribute('target') &&
		  event.originalTarget.parentNode.parentNode.getAttribute('target') == 'places'
		)
		||
		( //click on submenu
		  event.originalTarget.parentNode.parentNode.parentNode &&
		  event.originalTarget.parentNode.parentNode.parentNode.parentNode &&
		  event.originalTarget.parentNode.parentNode.parentNode.parentNode.hasAttribute('target') &&
		  event.originalTarget.parentNode.parentNode.parentNode.parentNode.getAttribute('target') == 'places'
		)
	   )
	  )
	{
		var selected = this._getSelectedPaths(false);
	}
	else
	{
	  var selected = this._getSelectedPaths(true);
	}
	return selected;
  }
  this.getSelectedRepos = function(event)
  {
	var aSelected = this.getSelectedPaths(event);
	var repos = [];
	for(var id in aSelected)
	{
	  var obj = this.getPaths(aSelected[id], true);
	  if(!repos[obj.git])
		repos[obj.git] = {};
	  //selected files
	  if(!repos[obj.git].selected)
		repos[obj.git].selected = [];
	  repos[obj.git].selected[repos[obj.git].selected.length] = obj.selected;
	  //selected recursive
	  if(!repos[obj.git].selectedRecursive)
		repos[obj.git].selectedRecursive = [];
	  repos[obj.git].selectedRecursive[repos[obj.git].selectedRecursive.length] = obj.selectedRecursive;
	  //object
	  if(!repos[obj.git].obj)
		repos[obj.git].obj = [];
	  repos[obj.git].obj[repos[obj.git].obj.length] = obj;
	  //cwd
	  if(!repos[obj.git].cwd)
		repos[obj.git].cwd = obj.cwd;
	}
	var obj = {};
		obj.sh = this.s.fileCreateTemporal('kGit.sh');
		obj.outputFile = this.s.fileCreateTemporal('kGit.diff');
		obj.output =' "'+this.s.filePathEscape(this.s.pathToNix(obj.outputFile))+'" ';
		
	return {'r' : repos, 'obj':obj};
  }

  this.getSelectedPathFolder = function(event)
  {
	var selected = this.getSelectedPaths(event)[0];
	  if(this.s.pathIsFolder(selected)){}
	  else
		selected = this.s.fileDirname(selected);
	return selected;
  }
  this.getPaths = function(aFile, noTemp)
  {
	var obj = {};
	
	if(!noTemp)
	{
	  obj.sh = this.s.fileCreateTemporal('kGit.sh');
	  //alert('sh:'+obj.sh);
	  
	  obj.outputFile = this.s.fileCreateTemporal('kGit.diff');
	  //alert('outputFile:'+obj.outputFile);

	  obj.output = ' "'+this.s.filePathEscape(this.s.pathToNix(obj.outputFile))+'" ';
	  //alert('output:'+obj.output);
	}
	
	obj.git = this.getGitRoot(aFile);
	//alert('git:'+obj.git);
	
	obj.cwd = ' "'+this.s.filePathEscape(this.s.pathToNix(obj.git))+'" ';
	//alert('cwd:'+obj.cwd);

	obj.selected = this.getPathRelativeToGit(aFile);
	obj.relativeToGit = obj.selected;
	obj.isFolder = this.s.pathIsFolder(aFile);
	//alert('selected:'+obj.selected);
	
	obj.cwdSelected = aFile;
	if(obj.isFolder)
	  obj.cwdSelected = ' "'+this.s.filePathEscape(this.s.pathToNix(obj.cwdSelected))+'" ';
	else
	  obj.cwdSelected = ' "'+this.s.filePathEscape(this.s.pathToNix(this.s.fileDirname(obj.cwdSelected)))+'" ';
	//alert('cwdSelected:'+obj.cwdSelected);
	  
	obj.selectedFile = aFile;
	//alert('selectedFile:'+obj.selectedFile);
	if(obj.selected == '')
	   obj.selected = ' . ';
	else
	   obj.selected = ' "'+this.s.filePathEscape(this.s.pathToNix(obj.selected))+'" ';
	
	//selected recursive
	if(obj.selected == '')
	   obj.selectedRecursive = ' . ';
	else
	{
	  if(obj.isFolder)
		obj.selectedRecursive = ' "'+this.s.filePathEscape(this.s.pathToNix(obj.relativeToGit))+'*" ';
	  else
		obj.selectedRecursive = ' "'+this.s.filePathEscape(this.s.pathToNix(obj.relativeToGit))+'" ';
	}
	//alert('selected:'+obj.selected);
	
	return obj;
  }
  
  //TODO allow user to use an external program for example winmerge.
  this.diff = function(event)
  {
	var selected = this.getSelectedPaths(event);
	for(var id in selected)
	{
	  var obj = this.getPaths(selected[id]);
	  this.s.fileWrite(obj.sh, 'cd '+obj.cwd+'\ngit diff HEAD -- '+obj.selected+' > '+obj.output+'\n');
	  this.run(obj.sh, obj.outputFile, 'No difference found', true);
	}
  }
  //TODO: hardcoded branch name
  this.diffBetweenLatestPushAndLastCommit = function(event)
  {
	var selected = this.getSelectedPaths(event);
	for(var id in selected)
	{
	  var obj = this.getPaths(selected[id]);
	  this.s.fileWrite(obj.sh, 'cd '+obj.cwd+'\ngit diff origin... -- '+obj.selected+' > '+obj.output+'\n');
	  this.run(obj.sh, obj.outputFile, 'No difference found', true);
	}
  }
  this.diffBetweenLatestTagAndLastCommit = function(event)
  {
	var selected = this.getSelectedPaths(event);
	for(var id in selected)
	{
	  var obj = this.getPaths(selected[id]);
	  var tags = this.tagsGetFromRepo(obj);
	  this.s.fileWrite(obj.sh, 'cd '+obj.cwd+'\ngit diff "'+(tags.pop() || '')+'"... -- '+obj.selected+' >>'+obj.output+' 2>&1\n');
	  this.run(obj.sh, obj.outputFile, 'No difference found', true);
	}
  }
  this.diffBetweenTheTwoLatestTags = function(event)
  {
	var selected = this.getSelectedPaths(event);
	for(var id in selected)
	{
	  var obj = this.getPaths(selected[id]);
	  var tags = this.tagsGetFromRepo(obj);
	  this.s.fileWrite(obj.sh, 'cd '+obj.cwd+'\ngit diff "'+(tags[tags.length-2] || '')+'".."'+(tags[tags.length-1] || '')+'" -- '+obj.selected+' >>'+obj.output+' 2>&1\n');
	  this.run(obj.sh, obj.outputFile, 'No difference found', true);
	}
  }

  this.logStatLatest = function(event)
  {
	var selected = this.getSelectedPaths(event);
	for(var id in selected)
	{
	  var obj = this.getPaths(selected[id]);
	  this.s.fileWrite(obj.sh, 'cd '+obj.cwd+' \n echo "log:'+this.s.filePathEscape(this.s.pathToNix(obj.selectedFile))+'" >> '+obj.output+' \n git log -n 30 --stat --graph -- '+ obj.selected+' >> '+obj.output+' \n');
	  this.run(obj.sh, obj.outputFile, 'No log to show', true);
	}
  }
  this.logStatFull = function(event)
  {
	var selected = this.getSelectedPaths(event);
	for(var id in selected)
	{
	  var obj = this.getPaths(selected[id]);
	  this.s.fileWrite(obj.sh, 'cd '+obj.cwd+' \n echo "log:'+this.s.filePathEscape(this.s.pathToNix(obj.selectedFile))+'" >> '+obj.output+' \n git log --stat --graph -- '+ obj.selected+' >> '+obj.output+' \n');
	  this.run(obj.sh, obj.outputFile, 'No log to show', true);
	}
  }
  this.logExtendedLatest = function(event)
  {
	var selected = this.getSelectedPaths(event);
	for(var id in selected)
	{
	  var obj = this.getPaths(selected[id]);
	  this.s.fileWrite(obj.sh, 'cd '+obj.cwd+' \n echo "log:'+this.s.filePathEscape(this.s.pathToNix(obj.selectedFile))+'" >> '+obj.output+' \n git log -n 30 -p -- '+ obj.selected+' >> '+obj.output+' \n');
	  this.run(obj.sh, obj.outputFile, 'No log to show', true);
	}
  }
  this.logExtendedFull = function(event)
  {
	var selected = this.getSelectedPaths(event);
	for(var id in selected)
	{
	  var obj = this.getPaths(selected[id]);
	  this.s.fileWrite(obj.sh, 'cd '+obj.cwd+' \n echo "log:'+this.s.filePathEscape(this.s.pathToNix(obj.selectedFile))+'" >> '+obj.output+' \n git log -p -- '+ obj.selected+' >> '+obj.output+' \n');
	  this.run(obj.sh, obj.outputFile, 'No log to show', true);
	}
  }
  this.logSinceLatestTag = function(event)
  {
	var selected = this.getSelectedPaths(event);
	for(var id in selected)
	{
	  var obj = this.getPaths(selected[id]);
	  var tags = this.tagsGetFromRepo(obj);
	  this.s.fileWrite(obj.sh, 'cd '+obj.cwd+'\n echo "log:'+this.s.filePathEscape(this.s.pathToNix(obj.selectedFile))+'" >> '+obj.output+' \n git log "'+(tags.pop() || '')+'"... --stat --graph -- '+obj.selected+' >>'+obj.output+' 2>&1\n');
	  this.run(obj.sh, obj.outputFile, 'No log to show', true);
	}
  }
  //TODO: Hardcoded remote and branch name
  this.logSinceLatestPush = function(event)
  {
	var selected = this.getSelectedPaths(event);
	for(var id in selected)
	{
	  var obj = this.getPaths(selected[id]);
	  var tags = this.tagsGetFromRepo(obj);
	  this.s.fileWrite(obj.sh, 'cd '+obj.cwd+'\n echo "log:'+this.s.filePathEscape(this.s.pathToNix(obj.selectedFile))+'" >> '+obj.output+' \n git log origin... --stat --graph -- '+obj.selected+' >>'+obj.output+' 2>&1\n');
	  this.run(obj.sh, obj.outputFile, 'No log to show', true);
	}
  }
  this.logBetweenTheTwoLatestTags = function(event)
  {
	var selected = this.getSelectedPaths(event);
	for(var id in selected)
	{
	  var obj = this.getPaths(selected[id]);
	  var tags = this.tagsGetFromRepo(obj);
	  this.s.fileWrite(obj.sh, 'cd '+obj.cwd+' echo "log:'+this.s.filePathEscape(this.s.pathToNix(obj.selectedFile))+'" >> '+obj.output+' \n git log "'+(tags[tags.length-2] || '')+'".."'+(tags[tags.length-1] || '')+'" --stat --graph -- '+obj.selected+' >>'+obj.output+' 2>&1\n');
	  this.run(obj.sh, obj.outputFile, 'No log to show', true);
	}
  }
  
  this.blame = function(event)
  {
	var selected = this.getSelectedPaths(event);
	for(var id in selected)
	{
	  if(!this.s.pathIsFolder(selected[id]))
	  {
		var obj = this.getPaths(selected[id]);
		this.s.fileWrite(obj.sh, 'cd '+obj.cwd+' \n git blame -- '+ obj.selected+' >> '+obj.output+' \n');
		this.run(obj.sh, obj.outputFile, '', true);
	  }
	}
  }
  
  this.status = function(event)
  {
	var selected = this.getSelectedPaths(event);
	for(var id in selected)
	{
	  var obj = this.getPaths(selected[id]);
	  this.s.fileWrite(obj.sh, 'cd '+obj.cwd+' \n echo "status:'+this.s.filePathEscape(this.s.pathToNix(obj.selectedFile))+'" >> '+obj.output+' \n git status --untracked-files=all -- '+ obj.selected+' >> '+obj.output+' \n');
	  this.run(obj.sh, obj.outputFile, '', true);
	}
  }
  
  this.revertTracked = function(event)
  {
	if(this.s.confirm('Discard changes to tracked on selected items?'))
	{
	  var selected = this.getSelectedPaths(event);
	  var commands = '';
	  for(var id in selected)
	  {
		var obj = this.getPaths(selected[id]);
		commands += 'cd '+obj.cwd+' ';
		commands += '\n';
		commands += 'git checkout HEAD -- '+ obj.selected+' >>'+obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(obj.sh, commands);
	  this.run(obj.sh, obj.outputFile, '', false, true);
	  this.kGitIconsOverlay.requestUpdate();
	}
  }
  this.revertTrackedCleanUntracked = function(event)
  {
	if(this.s.confirm('Discard changes to tracked and clean untracked on selected items?'))
	{
	  var selected = this.getSelectedPaths(event);
	  var commands = '';
	  for(var id in selected)
	  {
		var obj = this.getPaths(selected[id]);
		commands += 'cd '+obj.cwd+' ';
		commands += '\n';
		commands += 'git checkout HEAD -- '+ obj.selected+' >>'+obj.output+' 2>&1';
		commands += '\n';
		commands += 'git clean -f -d -- '+ obj.selected+' >>'+obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(obj.sh, commands);
	  this.run(obj.sh, obj.outputFile, '', false, true);
	  this.kGitIconsOverlay.requestUpdate();
	}
  }
  this.revertTrackedCleanUntrackedUnstage = function(event)
  {
	if(this.s.confirm('Discard changes to tracked, clean untracked and unstage on selected items?'))
	{
	  var selected = this.getSelectedPaths(event);
	  var commands = '';
	  for(var id in selected)
	  {
		var obj = this.getPaths(selected[id]);
		commands += 'cd '+obj.cwd+' ';
		commands += '\n';
		commands += 'git checkout HEAD -- '+ obj.selected+' >>'+obj.output+' 2>&1';
		commands += '\n';
		commands += 'git clean -f -d -- '+ obj.selected+' >>'+obj.output+' 2>&1';
		commands += '\n';
		commands += 'git reset HEAD -- '+ obj.selected+' >>'+obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(obj.sh, commands);
	  this.run(obj.sh, obj.outputFile, '', false, true);
	  this.kGitIconsOverlay.requestUpdate();
	}
  }
  this.revertTrackedUnstageCleanUntracked = function(event)
  {
	if(this.s.confirm('Discard changes to tracked, unstage and clean untracked on selected items?'))
	{
	  var selected = this.getSelectedPaths(event);
	  var commands = '';
	  for(var id in selected)
	  {
		var obj = this.getPaths(selected[id]);
		commands += 'cd '+obj.cwd+' ';
		commands += '\n';
		commands += 'git checkout HEAD -- '+ obj.selected+' >>'+obj.output+' 2>&1';
		commands += '\n';
		commands += 'git reset HEAD -- '+ obj.selected+' >>'+obj.output+' 2>&1';
		commands += '\n';
		commands += 'git clean -f -d -- '+ obj.selected+' >>'+obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(obj.sh, commands);
	  this.run(obj.sh, obj.outputFile, '', false, true);
	  this.kGitIconsOverlay.requestUpdate();
	}
  }
  this.revertUnstage = function(event)
  {
	if(this.s.confirm('Unstage selected items?'))
	{
	  var selected = this.getSelectedPaths(event);
	  var commands = '';
	  for(var id in selected)
	  {
		var obj = this.getPaths(selected[id]);
		commands += 'cd '+obj.cwd+' ';
		commands += '\n';
		commands += 'git reset HEAD -- '+ obj.selected+' >>'+obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(obj.sh, commands);
	  this.run(obj.sh, obj.outputFile, '', false, true);
	  this.kGitIconsOverlay.requestUpdate();
	}
  }
  this.checkoutRepositoryTo = function(event)
  {
	var aMsg = this.s.prompt('Checkout repository to object…');
	if(aMsg != '')
	{
	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += 'git checkout '+aMsg+' >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.run(repos.obj.sh, repos.obj.outputFile, '', false, true);
	  this.kGitIconsOverlay.requestUpdate();
	}
  }
  this.checkoutTo = function(event)
  {
	var aMsg = this.s.prompt('Checkout selected items to object…');
	if(aMsg != '')
	{
	  var selected = this.getSelectedPaths(event);
	  var commands = '';
	  for(var id in selected)
	  {
		var obj = this.getPaths(selected[id]);
		commands += 'cd '+obj.cwd+' ';
		commands += '\n';
		commands += 'git checkout '+aMsg+' -- '+ obj.selected+' >>'+obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(obj.sh, commands);
	  this.run(obj.sh, obj.outputFile, '', false, true);
	  this.kGitIconsOverlay.requestUpdate();
	}
  }
  this.remoteAdd = function(event)
  {
	var aMsg = this.s.prompt('Enter name and URL of remote…');
	if(aMsg != '')
	{
	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += 'git remote add '+aMsg+' >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.run(repos.obj.sh, repos.obj.outputFile, '', false, true);
	}
  }
  this.configDefaultRemote = function(event)
  {
	var aBranch = this.s.prompt('Enter the name of your local branch…');
	if(aBranch != '')
	  var aRemote = this.s.prompt('Enter the name of the remote…');
	if(aBranch != '' && aRemote != '')
	{
	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += 'git config branch.'+aBranch+'.remote '+aRemote+' >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.run(repos.obj.sh, repos.obj.outputFile, '', false, true);
	}
  }
  this.push = function(event)
  {
	var repos = this.getSelectedRepos(event);
	var commands = '';
	for(var id in repos.r)
	{
	  commands += 'cd '+repos.r[id].cwd+'';
	  commands += '\n';
	  commands += 'git push >>'+repos.obj.output+' 2>&1';
	  commands += '\n';
	}
	this.s.fileWrite(repos.obj.sh, commands);
	this.loadingSet();
	this.s.execute(this.gitPath, repos.obj.sh, repos.obj.outputFile, this.executeObserver);
  }
  this.pushPushTags = function(event)
  {
	var repos = this.getSelectedRepos(event);
	var commands = '';
	for(var id in repos.r)
	{
	  commands += 'cd '+repos.r[id].cwd+'';
	  commands += '\n';
	  commands += 'git push && git push --tags >>'+repos.obj.output+' 2>&1';
	  commands += '\n';
	}
	this.s.fileWrite(repos.obj.sh, commands);
	this.loadingSet();
	this.s.execute(this.gitPath, repos.obj.sh, repos.obj.outputFile, this.executeObserver);
  }
  this.pushTags = function(event)
  {
	var repos = this.getSelectedRepos(event);
	var commands = '';
	for(var id in repos.r)
	{
	  commands += 'cd '+repos.r[id].cwd+'';
	  commands += '\n';
	  commands += 'git push --tags >>'+repos.obj.output+' 2>&1';
	  commands += '\n';
	}
	this.s.fileWrite(repos.obj.sh, commands);
	this.loadingSet();
	this.s.execute(this.gitPath, repos.obj.sh, repos.obj.outputFile, this.executeObserver);
  }
  this.pushWithOptions = function(event)
  {
	var aOptions = this.s.prompt('Push with options…', 'git push aRemoteName aLocalBranch:aRemoteBranch');
	if(aOptions != '')
	{
	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += aOptions+' >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.loadingSet();
	  this.s.execute(this.gitPath, repos.obj.sh, repos.obj.outputFile, this.executeObserver);
	}
  }
  this.pull = function(event)
  {
	if(this.s.confirm('Pull from default?'))
	{
	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += 'git pull >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.loadingSet();
	  this.s.execute(this.gitPath, repos.obj.sh, repos.obj.outputFile, this.executeObserver);
	  this.kGitIconsOverlay.requestUpdate();
	}
  }
  this.pullWithOptions = function(event)
  {
	var aOptions = this.s.prompt('Pull with options…', 'git pull');
	if(aOptions != '')
	{
	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += aOptions+' >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.loadingSet();
	  this.s.execute(this.gitPath, repos.obj.sh, repos.obj.outputFile, this.executeObserver);
	  this.kGitIconsOverlay.requestUpdate();
	}
  }
  this.fetch = function(event)
  {
	if(this.s.confirm('Fetch from default?'))
	{
	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += 'git fetch >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.loadingSet();
	  this.s.execute(this.gitPath, repos.obj.sh, repos.obj.outputFile, this.executeObserver);
	  this.kGitIconsOverlay.requestUpdate();
	}
  }
  this.fetchWithOptions = function(event)
  {
	var aOptions = this.s.prompt('Fetch with options…', 'git fetch aRemoteName aRemoteBranch:aLocalBranch');
	if(aOptions != '')
	{
	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += aOptions+' >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.loadingSet();
	  this.s.execute(this.gitPath, repos.obj.sh, repos.obj.outputFile, this.executeObserver);
	  this.kGitIconsOverlay.requestUpdate();
	}
  }
  
  this.init = function(event)
  {
	var selected = this.getSelectedPathFolder(event);
	var obj = this.getPaths(selected);
	this.s.fileWrite(obj.sh, 'cd '+obj.cwdSelected+' \ngit init >>'+obj.output+' 2>&1');
	this.run(obj.sh, obj.outputFile, '', false, true);
	this.kGitIconsOverlay.cleanRepositoriesCache();
  }
  this.clone = function(event)
  {
	var aMsg = this.s.prompt('Enter URL to clone…');
	if(aMsg != '')
	{
	  aMsg = aMsg.replace(/^ ?git clone ?/, '');
	  var selected = this.getSelectedPathFolder(event);
	  var obj = this.getPaths(selected);
	  this.s.fileWrite(obj.sh, 'cd '+obj.cwdSelected+' \ngit clone '+aMsg+' ./ >>'+obj.output+' 2>&1');
	  this.loadingSet();
	  this.s.execute(this.gitPath, obj.sh, obj.outputFile, this.executeObserver);
	  this.kGitIconsOverlay.cleanRepositoriesCache();
	}
  }
  this.submoduleAdd = function(event)
  {
	var aMsg = this.s.prompt('Enter URL of submodule…');
	if(aMsg != '')
	  var aFolder = this.s.prompt('Enter a folder for the submodule…');
	if(aMsg != '' && aFolder != '')
	{
	  var selected = this.getSelectedPaths(event);
	  var commands = '';
	  for(var id in selected)
	  {
		var obj = this.getPaths(selected[id]);
		commands += 'cd '+obj.cwd+' ';
		commands += '\n';
		commands += 'git submodule add "'+this.s.filePathEscape(aMsg)+'" "'+this.s.filePathEscape(this.s.pathToNix(obj.relativeToGit))+'/'+this.s.filePathEscape(aFolder)+'">>'+obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(obj.sh, commands);
	  this.loadingSet();
	  this.s.execute(this.gitPath, obj.sh, obj.outputFile, this.executeObserver);
	  this.kGitIconsOverlay.requestUpdate();
	}
  }
  this.command = function(event)
  {
	var selected = this.getSelectedPathFolder(event);
	var obj = this.getPaths(selected);
	
	var aMsg = this.s.prompt('[komodin@komodo '+obj.cwdSelected+'] $ ', 'git ');
	if(aMsg != '')
	{
	  this.s.fileWrite(obj.sh, 'cd '+obj.cwdSelected+' \n'+aMsg+' >>'+obj.output+' 2>&1');
	  this.loadingSet();
	  this.s.execute(this.gitPath, obj.sh, obj.outputFile, function(a,b){ kgit.executeObserver(a,b,true)});
	}
  }
  
  
  //TODO: show "Changes to be committed".
  this.commit = function(event)
  {
	if(event.aMsg && event.aMsg != '')
	{
	  var aMsg = this.s.ucFirst(event.aMsg);

	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += 'git commit -m "'+this.s.filePathEscape(aMsg)+'" -- '+repos.r[id].selected.join(' ')+' >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.run(repos.obj.sh, repos.obj.outputFile, '', false, true);
	  this.kGitIconsOverlay.requestUpdate();
	}
	else
	{
	  this.s.prompt('Enter a commit message…', '', true, function(event){ kgit.commit(event)}, event);
	}
  }
  this.commitAll = function(event)
  {
	if(event.aMsg && event.aMsg != '')
	{
	  var aMsg =  this.s.ucFirst(event.aMsg);

	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += 'git commit -a -m "'+this.s.filePathEscape(aMsg)+'" >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.run(repos.obj.sh, repos.obj.outputFile, '', false, true);
	  this.kGitIconsOverlay.requestUpdate();
	}
	else
	{
	  this.s.prompt('Enter a commit message…', '', true, function(event){ kgit.commitAll(event)}, event);
	}
  }
  this.commitAmend = function(event)
  {
	var repos = this.getSelectedRepos(event);
	var commands = '';
	for(var id in repos.r)
	{
	  commands += 'cd '+repos.r[id].cwd+'';
	  commands += '\n';
	  commands += 'git commit --amend -C HEAD -- '+repos.r[id].selected.join(' ')+' >>'+repos.obj.output+' 2>&1';
	  commands += '\n';
	}
	this.s.fileWrite(repos.obj.sh, commands);
	this.run(repos.obj.sh, repos.obj.outputFile, '', false, true);
	this.kGitIconsOverlay.requestUpdate();
  }
  this.commitUndo = function(event)
  {
	if(this.s.confirm('Undo Last Commit?'))
	{
	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += 'git reset --soft HEAD^ >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.run(repos.obj.sh, repos.obj.outputFile, '', false, true);
	  this.kGitIconsOverlay.requestUpdate();
	}
  }
  this.addCommit = function(event)
  {
	if(event.aMsg && event.aMsg != '')
	{
	  var aMsg =  this.s.ucFirst(event.aMsg);

	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += 'git add -- '+repos.r[id].selectedRecursive.join(' ')+' >>'+repos.obj.output+' 2>&1';
		commands += '\n';
		commands += 'git commit -m "'+this.s.filePathEscape(aMsg)+'" -- '+repos.r[id].selected.join(' ')+' >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.run(repos.obj.sh, repos.obj.outputFile, '', false, true);
	  this.kGitIconsOverlay.requestUpdate();
	}
	else
	{
	  this.s.prompt('Enter a commit message…', '', true, function(event){ kgit.addCommit(event)}, event);
	}
  }
  this.addCommitPush = function(event)
  {
	if(event.aMsg && event.aMsg != '')
	{
	  var aMsg =  this.s.ucFirst(event.aMsg);

	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += 'git add -- '+repos.r[id].selectedRecursive.join(' ')+' >>'+repos.obj.output+' 2>&1';
		commands += '\n';
		commands += 'git commit -m "'+this.s.filePathEscape(aMsg)+'" -- '+repos.r[id].selected.join(' ')+' >>'+repos.obj.output+' 2>&1';
		commands += '\n';
		commands += 'git push >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.loadingSet();
	  this.s.execute(this.gitPath, repos.obj.sh, repos.obj.outputFile, this.executeObserver);
	}
	else
	{
	  this.s.prompt('Enter a commit message…', '', true, function(event){ kgit.addCommitPush(event)}, event);
	}
  }
  this.add = function(event)
  {
	var repos = this.getSelectedRepos(event);
	var commands = '';
	for(var id in repos.r)
	{
	  commands += 'cd '+repos.r[id].cwd+'';
	  commands += '\n';
	  commands += 'git add -- '+repos.r[id].selectedRecursive.join(' ')+' >>'+repos.obj.output+' 2>&1';
	  commands += '\n';
	}
	this.s.fileWrite(repos.obj.sh, commands);
	this.run(repos.obj.sh, repos.obj.outputFile, '', false, true);
	this.kGitIconsOverlay.requestUpdate();
  }
  this.removeKeepLocal = function(event)
  {
	if(this.s.confirm('Remove selected items from the repository and keep the local copy?'))
	{
	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += 'git rm -r --cached -- '+repos.r[id].selected.join(' ')+' >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.run(repos.obj.sh, repos.obj.outputFile, '', false, true);
	  this.kGitIconsOverlay.requestUpdate();
	}
  }
  this.remove = function(event)
  {
	if(this.s.confirm('Remove selected items from the repository?'))
	{
	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += 'git rm -r -f -- '+repos.r[id].selected.join(' ')+' >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.run(repos.obj.sh, repos.obj.outputFile, '', false, true);
	  this.kGitIconsOverlay.requestUpdate();
	}
  }
  this.tagAdd = function(event)
  {
	var aMsg = this.s.prompt('Enter tag name to add…', '');
	if(aMsg != '')
	{
	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += 'git tag "'+this.s.filePathEscape(aMsg)+'" >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.run(repos.obj.sh, repos.obj.outputFile, 'Tag "'+aMsg+'" added', false, true);
	}
  }
  this.tagRemove = function(event)
  {
	var aMsg = this.s.prompt('Enter tag name to remove…', '');
	if(aMsg != '')
	{
	  var repos = this.getSelectedRepos(event);
	  var commands = '';
	  for(var id in repos.r)
	  {
		commands += 'cd '+repos.r[id].cwd+'';
		commands += '\n';
		commands += 'git tag -d "'+this.s.filePathEscape(aMsg)+'" >>'+repos.obj.output+' 2>&1';
		commands += '\n';
	  }
	  this.s.fileWrite(repos.obj.sh, commands);
	  this.run(repos.obj.sh, repos.obj.outputFile, '', false, true);
	}
  }
  this.tagAuto = function(event)
  {
	var repos = this.getSelectedRepos(event);
	var commands = '';
	for(var id in repos.r)
	{
	  var version = this.repositoryPreference(id, 'version') || 0;
		  version++;
	  this.repositoryPreference(id, 'version', version);
	
	  commands += 'cd '+repos.r[id].cwd+'';
	  commands += '\n';
	  commands += 'git tag "'+this.s.filePathEscape(this.s.now().replace(/-/g, '').substr(2, 6)+'.'+version)+'" >>'+repos.obj.output+' 2>&1';
	  commands += '\n';
	}
	this.s.fileWrite(repos.obj.sh, commands);
	this.run(repos.obj.sh, repos.obj.outputFile, 'Tag '+this.s.now().replace(/-/g, '').substr(2, 6)+' added', false, true);
  }
  this.tagList = function(event)
  {
	var repos = this.getSelectedRepos(event);
	var commands = '';
	for(var id in repos.r)
	{
	  commands += 'cd '+repos.r[id].cwd+'';
	  commands += '\n';
	  commands += 'git tag -l >>'+repos.obj.output+' 2>&1';
	  commands += '\n';
	}
	this.s.fileWrite(repos.obj.sh, commands);
	this.run(repos.obj.sh, repos.obj.outputFile, '', true, false);
  }
  this.tagsGetFromRepo = function(aObj)
  {
	var sh = this.s.fileCreateTemporal('kGit.sh', '');

	this.s.fileWrite(sh, 'cd '+aObj.cwd+' \n echo `git for-each-ref refs/tags --sort=-authordate` \n');
	
	var tags = this.run(sh, sh+'.diff', '', false, false, true).split('\n');
		tags.shift();
		tags.shift();
		tags.shift();
		tags.shift();
		tags.shift();
		tags = tags.join('');
		tags = tags.split('refs/tags/');
		tags.shift();
		for(var id in tags)
		  tags[id] = tags[id].split(' ')[0];
		tags.reverse();
	return tags;
  }
  
  this.ignoreOpen = function(event)
  {
	var selected = this.getSelectedPaths(event);
	var aPath;
	
	for(var id in selected)
	{
	  aPath = selected[id];

	  while(!this.s.fileExists(aPath+this.s.__DS+'.git'+this.s.__DS))
	  {

		if(this.s.fileExists(aPath+this.s.__DS+'.gitignore'))
		  break;
		if(this.s.fileDirname(aPath) == aPath)
		  break;
		aPath = this.s.fileDirname(aPath);
	  }
	  if(this.s.fileExists(aPath+this.s.__DS+'.gitignore'))
	  {
		this.s.openURL(window, aPath+this.s.__DS+'.gitignore', true);
	  }
	  else
	  {
		if(this.s.confirm('.gitignore file was not found. Do you want to create one?'))
		{
		  this.s.fileWrite(aPath+this.s.__DS+'.gitignore', '\n');
		  this.s.openURL(window, aPath+this.s.__DS+'.gitignore', true);
		}
	  }
	}
  }
  //adds selected files to gitignore on close parent gitignore.
  this.ignore = function(event)
  {
	var selected = this.getSelectedPaths(event);
	var aPath;
	
	for(var id in selected)
	{
	  if(this.s.pathIsFolder(selected[id]))
		aPath = this.s.fileDirname(selected[id]);
	  else
		aPath = selected[id];
		
	  while(!this.s.fileExists(aPath+this.s.__DS+'.git'+this.s.__DS))
	  {
		if(this.s.fileExists(aPath+this.s.__DS+'.gitignore'))
		  break;
		if(this.s.fileDirname(aPath) == aPath)
		  break;
		aPath = this.s.fileDirname(aPath);
	  }
	  
	  if(this.s.fileExists(aPath+this.s.__DS+'.gitignore'))
	  {
		var ignore = this.s.fileRead(aPath+this.s.__DS+'.gitignore');
			ignore += '\n';
			if(this.s.pathIsFolder(selected[id]))
			  ignore += (selected[id].replace(aPath+this.s.__DS, '')+this.s.__DS).split(this.s.__DS).join('/');
			else
			  ignore += (selected[id].replace(aPath+this.s.__DS, '')).split(this.s.__DS).join('/');
			ignore = this.s.arrayUnique(ignore.split('\n')).sort(this.s.sortLocale).join('\n');
	  }
	  else
	  {
		if(this.s.pathIsFolder(selected[id]))
		  var ignore = (selected[id].replace(this.getGitRoot(aPath)+this.s.__DS, '')+this.s.__DS).split(this.s.__DS).join('/');
		else
		  var ignore = (selected[id].replace(this.getGitRoot(aPath)+this.s.__DS, '')).split(this.s.__DS).join('/');
	  }
	  ignore += '\n';

	  this.s.fileWrite(aPath+this.s.__DS+'.gitignore', ignore);
	  this.s.openURL(window, aPath+this.s.__DS+'.gitignore', true);
	}
	this.kGitIconsOverlay.requestUpdate();
  }
  this.getGitRoot = function(aPath)
  {
	var originalPath = aPath;
	while(!this.s.fileExists(aPath+this.s.__DS+'.git'+this.s.__DS))
	{
	  if(this.s.fileDirname(aPath) == aPath)
		break;
	  aPath = this.s.fileDirname(aPath);
	  if(this.s.fileExists(aPath+this.s.__DS+'.git'+this.s.__DS))
		break;
	}
	if(this.s.fileExists(aPath+this.s.__DS+'.git'+this.s.__DS))
	  return aPath;
	else
	{
	  if(this.s.pathIsFolder(originalPath))
		return originalPath;
	  else
		return this.s.fileDirname(originalPath);
	}
  }
  this.getPathRelativeToGit = function(aPath)
  {
	var dir = aPath.split(this.getGitRoot(aPath)+this.s.__DS);
		dir.shift();
	return dir.join('');
  }
  //TODO: open "git gui" without a terminal
  this.gitGUI = function(event)
  {
	var selected = this.getSelectedPaths(event);
	var commands = '';
	for(var id in selected)
	{
	  var obj = this.getPaths(selected[id]);

	  commands += 'cd '+obj.cwdSelected+'';
	  commands += '\n';
	  commands += 'git gui';
	  commands += '\n';
	}

	this.s.fileWrite(obj.sh, commands);
	this.loadingSet();
	this.s.execute(this.gitPath, obj.sh, null, this.executeObserver);
  }
  //TODO: open "gitk" without a terminal
  this.gitK = function(event)
  {
	var selected = this.getSelectedPaths(event);
	var commands = '';
	for(var id in selected)
	{
	  var obj = this.getPaths(selected[id]);

	  commands += 'cd '+obj.cwdSelected+'';
	  commands += '\n';
	  commands += 'gitk';
	  commands += '\n';
	}

	this.s.fileWrite(obj.sh, commands);
	this.loadingSet();
	this.s.execute(this.gitPath, obj.sh, null, this.executeObserver);
  }
  this.repositoryPreference = function(aRepository, aName, aValue)
  {
	var file = aRepository+this.s.__DS+'.git'+this.s.__DS+'komodin.json';
	var obj = {};
	if(this.s.fileExists(file))
	  obj = JSON.parse(this.s.fileRead(file));
	if(typeof(aValue) == 'undefined'){}
	else
	{
	  obj[aName] = aValue;
	  this.s.fileWrite(file, JSON.stringify(obj));
	}
	return obj[aName];
  }
  this.cleanRepositoriesCache = function()
  {
	this.kGitIconsOverlay.cleanRepositoriesCache();
  }



/* menu */
  this.menuClick = function(event)
  {
	var item = event.originalTarget.parentNode;
	if(item.state)
	  item.hidePopup();
	if(item.parentNode.state)
	  item.parentNode.hidePopup();
	if(item.parentNode.parentNode.state)
	  item.parentNode.parentNode.hidePopup();
	event.stopPropagation();
  }
  this.loadingSet = function()
  {
	this.itemsLoading++;
	this.element('kgit-toolbarbutton').setAttribute('loading', true);
	if(this.element('kgit-places-file-popup'))
	  this.element('kgit-places-file-popup').setAttribute('loading', true);
	if(this.element('kgit-garden-file-popup'))
	  this.element('kgit-garden-file-popup').setAttribute('loading', true);
	this.element('kgit-document-context-menu').setAttribute('loading', true);
	this.element('kgit-tab-context-menu').setAttribute('loading', true);
	this.element('kgit-menu-bar-file').setAttribute('loading', true);
  }
  this.loadingRemove = function()
  {
	this.itemsLoading--;
	if(this.itemsLoading == 0)
	{
	  this.element('kgit-toolbarbutton').removeAttribute('loading');
	  if(this.element('kgit-places-file-popup'))
		this.element('kgit-places-file-popup').removeAttribute('loading');
	  if(this.element('kgit-garden-file-popup'))
		this.element('kgit-garden-file-popup').removeAttribute('loading');
	  this.element('kgit-document-context-menu').removeAttribute('loading');
	  this.element('kgit-tab-context-menu').removeAttribute('loading');
	  this.element('kgit-menu-bar-file').removeAttribute('loading');
	}
  }
  this.disable = function()
  {
	this.element('kgit-toolbarbutton').setAttribute('disabled', true);
	if(this.element('kgit-places-file-popup'))
	  this.element('kgit-places-file-popup').setAttribute('disabled', true);
	if(this.element('kgit-garden-file-popup'))
	  this.element('kgit-garden-file-popup').setAttribute('disabled', true);
	this.element('kgit-document-context-menu').setAttribute('disabled', true);
	this.element('kgit-tab-context-menu').setAttribute('disabled', true);
	this.element('kgit-menu-bar-file').setAttribute('disabled', true);
  }
  
  this.element = function(anElement)
  {
	return document.getElementById(anElement);
  }
  this.dump = function(aName, aData, aError)
  {
	if(!this.debug && !aError)
	  return;
	this.s.dump(aName, aData);
  }

  return this;
}

var kgit = new kGit();

addEventListener('load', kgit.loadExtension, false);
addEventListener('unload', kgit.unloadExtension, false);